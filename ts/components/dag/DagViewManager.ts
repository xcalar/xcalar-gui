class DagViewManager {
    private containerSelector: string = "#dagView";
    private $dagView: JQuery;
    private $dfWrap: JQuery;
    private activeDag: DagGraph;
    private activeDagTab: DagTab;

    private activeDagView: DagView;
    private dagViewMap: Map<string, DagView>;
    private _setup: boolean;
    private _isCopying: boolean;

    private static _instance: DagViewManager;

    public static get Instance() {
        return this._instance || (this._instance = new this());
    }

    private constructor() {
        this._setup = false;
    }

    public setup(): void {
        if (this._setup) {
            return;
        }
        this._setup = true;

        this.$dagView = this._getDagViewEl();
        this.$dfWrap = this.$dagView.find(".innerDataflowWrap");

        DagView.setup();

        this.activeDag = null;
        this.activeDagTab = null;
        this.activeDagView = null;
        this.dagViewMap = new Map();

        this._addEventListeners();
        this._addDagViewListeners();


        DagGraphBar.Instance.setup();
        DagCategoryBar.Instance.setup();
        DagCategoryBar.Instance.loadCategories(); // Async call
        DagNodeMenu.setup();
        DagComment.Instance.setup();
        DagParamManager.Instance.setup();

        if (UserSettings.Instance.getPref("dfProgressTips")) {
            this.toggleProgressTips(true);
        }
        if (UserSettings.Instance.getPref("dfConfigInfo")) {
            this.toggleConfigInfo(true);
        }
        if (UserSettings.Instance.getPref("dfTableName")) {
            this.toggleTableName(true);
        }
        if (UserSettings.Instance.getPref("dfLabel")) {
            this.toggleLabels(true);
        }
        if (UserSettings.Instance.getPref("dfPinOperatorBar")) {
            this.pinOperatorBar(true);
        }
    }

    /**
     * Called when dag panel becomes visible, listeners that are removed when
     * panel closes.
     */
    public show(): void {
        const self = this;
        this.hide(); // reset the panel
        DagCategoryBar.Instance.showOrHideArrows();
        TblFunc.moveFirstColumn();

        if (this.activeDagView) {
            this.activeDagView.focus();
        }

        let resizeTimer;
        $(window).on("resize.dagViewResize", function () {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                DagCategoryBar.Instance.showOrHideArrows();
            }, 300);
        });

        $(document).on("copy.dataflowPanel", function (e) {
            if (!self._isCopying) { // not generated by node menu
                if ($(e.target).is("textarea")) {
                    // when it's on codemirror editor
                    return;
                }
                 if (!self.activeDagView) {
                    return;
                }
                if ($(e.target).is("body")) {
                    // proceed
                } else if ($(e.target).is(".xcClipboardArea")) {
                    return;
                } else if (window.getSelection().toString().length &&
                    window.getSelection().toString() !== " ") {
                    // if an actual target is selected,
                    // then let the natural event occur
                    return;
                }
            }

            const nodesStr = self.copyNodes(self.getSelectedNodeIds(true, true));
            e.originalEvent.clipboardData.setData("text/plain", nodesStr);
            e.preventDefault(); // default behaviour is to copy any selected text
        });

        $(document).on("cut.dataflowPanel", function (e) {
            if (!self._isCopying) {
                if ($(e.target).is("textarea")) {
                    // when it's on codemirror editor
                    return;
                }
                if (!self.activeDagView) {
                    return;
                }
                if (self.isDisableActions(true)) {
                    return;
                }
                if ($(e.target).is("body")) {
                    // proceed
                } else if ($(e.target).is(".xcClipboardArea")) {
                    return;
                } else if (window.getSelection().toString().length &&
                    window.getSelection().toString() !== " ") {
                    // if an actual target is selected,
                    // then let the natural event occur
                    return;
                }
            }
            const nodeIds = self.getSelectedNodeIds(true, true);
            const nodesToCheck = nodeIds.filter((nodeId) => {
                return !nodeId.startsWith("comment");
            });
            let lockedTable = DagViewManager.Instance.getActiveDag().checkForChildLocks(nodesToCheck);
            if (lockedTable) {
                DagUtil.showPinWarning(lockedTable);
            } else if (FormHelper.activeForm) {
                Alert.show({
                    title: `Configuration Panel Open`,
                    msg: `This action cannot be performed while the ${FormHelper.activeFormName} configuration panel is open. Do you want to exit the panel and proceed?`,
                    onConfirm: () => {
                        DagConfigNodeModal.Instance.closeForms();
                        const nodesStr = self.cutNodes(nodeIds);
                        e.originalEvent.clipboardData.setData("text/plain", nodesStr);
                    }
                });
            } else {
                const nodesStr = self.cutNodes(nodeIds);
                e.originalEvent.clipboardData.setData("text/plain", nodesStr);
            }

            e.preventDefault(); // default behaviour is to copy any selected text
        });

        $(document).on("paste.dataflowPanel", function (e: JQueryEventObject) {

            if ($(e.target).is("input") || $(e.target).is("textarea")) {
                return; // use default paste event
            }
            let content = e.originalEvent.clipboardData.getData('text/plain');
            self.paste(content);
        });

        $(document).on("keydown.dataflowPanel", function (e: JQueryEventObject) {
            if (!$("#sqlWorkSpacePanel").is(":visible")) {
                return;
            }
            if (self.activeDag == null ||
                self.activeDag.isLocked() ||
                $("input:focus").length || $("textarea:focus").length ||
                $('[contentEditable="true"]').length
            ) {
                return;
            }
            switch (e.which) {
                case (keyCode.Backspace):
                case (keyCode.Delete):
                    if (FormHelper.activeForm) {
                        StatusBox.show(TooltipTStr.CloseConfigForm, FormHelper.activeForm.getPanel());
                        return;
                    }
                    if (self.isDisableActions(true)) {
                        break;
                    }
                    DagNodeMenu.close();
                    const nodeIds = self.activeDagView.getSelectedNodeIds(true, true);
                    const nodesToCheck = nodeIds.filter((nodeId) => {
                        return !nodeId.startsWith("comment");
                    });
                    let pinnedTable = DagViewManager.Instance.getActiveDag().checkForChildLocks(nodesToCheck);
                    if (pinnedTable) {
                        DagUtil.showPinWarning(pinnedTable);
                    } else {
                        self.activeDagView.removeNodes(nodeIds);
                    }
                    break;
                case (keyCode.Y):
                case (keyCode.Z):
                    checkUndoRedo(e);
                    break;
                default:
                    break;
            }
        });

        function checkUndoRedo(event: JQueryEventObject): void {
            if (!(isSystemMac && event.metaKey) &&
                !(!isSystemMac && event.ctrlKey)) {
                return;
            }
            if (FormHelper.activeForm ||
                !$('#sqlWorkSpacePanel').hasClass('active') ||
                $('#container').hasClass('columnPicker') ||
                $('.modalContainer:not(#aboutModal):visible').length ||
                $('textarea:focus').length ||
                $('input:focus').length
            ) {
                if (FormHelper.activeForm) {
                    StatusBox.show(TooltipTStr.CloseConfigForm, FormHelper.activeForm.getPanel());
                }
                return;
            }

            event.preventDefault();
            xcMenu.close();
            // TblManager.unHighlightCells();

            if (event.which === keyCode.Y ||
                (event.which === keyCode.Z && event.shiftKey)) {
                if ($("#redo").hasClass("disabled")) {
                    Log.repeat();
                } else {
                    $('#redo').click();
                }
            } else if (event.which === keyCode.Z) {
                $('#undo').click();
            }
        }
    }

    /**
     * Called when navigating away from dag panel
     */
    public hide(): void {
        $(window).off(".dagViewResize");
        $(document).off(".dataflowPanel");
        if (this.activeDagView) {
            this.activeDagView.unfocus();
        }
    }

    public getActiveDagView(): DagView {
        return this.activeDagView;
    }

     /**
     * Returns the current activeDag
     * @returns {DagGraph}
     */
    public getActiveDag(): DagGraph {
        return this.activeDag;
    }

    public getActiveTab(): DagTab {
        return this.activeDagTab;
    }

    public getAreaByTab(tabId: string): JQuery {
        return this._getAreaByTab(tabId);
    }

    public getActiveArea(): JQuery {
        return this._getActiveArea();
    }

    public focusOnNode(nodeId: DagNodeId, tabId: string): XDPromise<JQuery> {
        const deferred: XDDeferred<JQuery> = PromiseHelper.deferred();

        let dagTab: DagTab = DagList.Instance.getDagTabById(tabId);
        if (dagTab == null){
            return PromiseHelper.reject();
        }
        DagTabManager.Instance.loadTab(dagTab)
        .then(() => {
            const $node: JQuery = DagViewManager.Instance.getNode(nodeId);
            $node.length ? deferred.resolve($node) : deferred.reject();
        })
        .fail(deferred.reject);

        return deferred.promise();
    }

    public addDataflowHTML($container: JQuery, tabId: string, isViewOnly?: boolean, isProgressGraph?: boolean) {
        $container.append(
            '<div class="dataflowArea ' + (isViewOnly? 'viewOnly': '') + ' ' +
                (isProgressGraph? 'progressGraph': '') + '" data-id="' +tabId + '">\
                <div class="dataflowAreaWrapper">\
                    <div class="commentArea"></div>\
                    <svg class="edgeSvg"></svg>\
                    <svg class="operatorSvg"></svg>\
                </div>\
            </div>'
        );
    }

    /**
     * DagView.getNode
     * @param nodeId
     * @param tabId?
     * @param $dataflowArea?
     * returns $(".operator") element
     */
    public getNode(
        nodeId: DagNodeId,
        tabId?: string,
        $dataflowArea?: JQuery
    ): JQuery {
        if (tabId) {
            $dataflowArea = this._getAreaByTab(tabId);
        }
        $dataflowArea = $dataflowArea || this._getActiveArea();
        return $dataflowArea.find('.operator[data-nodeid="' + nodeId + '"]');
    }

    public getNodeAndTabById(nodeId): {node: DagNode, tab: DagTab} {
        let node: DagNode;
        let tab: DagTab;
        try {
            node = this.activeDag.getNode(nodeId);
            if (!node) {
                let id, view;
                for ([id, view] of this.dagViewMap) {
                    node = view.graph.getNode(nodeId);
                    if (node) {
                        let tabId = view.graph.getTabId();
                        tab = DagTabManager.Instance.getTabById(tabId);
                        // console.log("Application Builder Module: " + tab.getName());
                        // console.log(view.$dfArea.find('.operator[data-nodeid="' + nodeId + '"]'));
                        break;
                    }
                }
            }
        } catch (e) {
            console.error(e);
        }
        return {
            node: node,
            tab: tab
        };
    }

    /**
     * DagViewManager.Instance.viewResult
     * @param dagNodeId
     */
    public viewResult(dagNode: DagNode, tabId?: string): XDPromise<void> {
        const deferred: XDDeferred<void> = PromiseHelper.deferred();
        try {
            if (dagNode instanceof DagNodeAggregate) {
                this._viewAgg(dagNode);
                deferred.resolve();
            } else {
                // all other nodes
                tabId = tabId || this.activeDagTab.getId();
                const meta = {
                    tabId,
                    nodeId: dagNode.getId()
                };
                let displayName;
                let type;
                if (dagNode.isHidden()) {
                    displayName = "Preview";
                    type = TableTabType.Preview;
                } else {
                    displayName = dagNode.getTable();
                    type = TableTabType.ResultSet;
                }
                TableTabManager.Instance.openTab(dagNode.getTable(), type, meta, displayName)
                .then(() => {
                    deferred.resolve();
                })
                .catch((error) => {
                    deferred.reject(error);
                });
            }
        } catch (e) {
            console.error(e);
            Alert.error(AlertTStr.Error, ErrTStr.Unknown);
            deferred.reject(e);
        }

        return deferred.promise();
    }

    /**
     * DagViewManager.Instance.removeProgress
     * @param nodeId
     * @param tabId
     */
    public removeProgressPct(nodeId: DagNodeId, tabId: string): void {
        if (this.dagViewMap.has(tabId)) {
            this.dagViewMap.get(tabId).removeProgressPct(nodeId);
        }
    }

    /**
     * DagViewManager.Instance.switchActiveDagTab
     * Switches the current active tab, updating activeDag and activeDagTab
     * @param dagTab The tab we want to make active.
     */
    public switchActiveDagTab(dagTab: DagTab, $dfArea?: JQuery) {
        this.activeDagTab = dagTab;
        this.activeDag = dagTab.getGraph();
        if (this.activeDagView) {
            this.activeDagView.unfocus();
        }
        if (this.dagViewMap.has(dagTab.getId())) {
            this.activeDagView = this.dagViewMap.get(dagTab.getId());
        }
        DagCategoryBar.Instance.updateCategories(this.activeDagTab);
        DagNodeMenu.updateCategories();
        this.render($dfArea);
        this.activeDagView.focus();
        this._updateDagView();
        // DagTable.Instance.switchTab(dagTab.getId());
        DagSearch.Instance.switchTab();
        this.activeDagView.updateOperationTime();
        DagUDFErrorModal.Instance.close();
    }

    public endOptimizedDFProgress(queryName: string, queryStateOutput, dagTab?): void {
        let tab: DagTabProgress;
        if (dagTab) {
            tab = dagTab;
        } else {
            tab = <DagTabProgress>DagTabManager.Instance.getTabById(queryName);

        }
        if (!tab) {
            return;
        }

        this.updateProgressDataflow(queryName, queryStateOutput);
        tab.getGraph().endProgress(queryStateOutput.queryState, queryStateOutput.elapsed.milliseconds);
    }

    // for view only dataflows: i.e. optimized dataflow or abandoned dataflow
    public updateProgressDataflow(queryName, queryStateOutput): void {
        const dagTab = <DagTabProgress>DagTabManager.Instance.getTabById(queryName);
        if (!dagTab) {
            return;
        }
        const graph = dagTab.getGraph();
        graph.updateSubGraphProgress(queryStateOutput.queryGraph.node, !(dagTab instanceof DagTabOptimized));
    }

    public updateDFProgress(tabId: string, queryStateOutput: XcalarApiQueryStateOutputT): void {
        const dagView: DagView = this.dagViewMap.get(tabId);
        let graph: DagGraph = null;
        if (dagView) {
            graph = dagView.getGraph();
        } else {
            // if graph is load with switchTabAfterLoad = false,
            // it will not render as DagView yet
            const tab = DagTabManager.Instance.getTabById(tabId);
            if (tab) {
                graph = tab.getGraph();
            }
        }

        if (graph != null) {
            graph.updateProgress(queryStateOutput.queryGraph.node);
        }
    }

    public updateDatasetProgress(tabId: string, nodeId: DagNodeId, stats: {
        elapsedTime: number,
        progress: number,
        dsName: string,
        finished?: boolean
    }) {
        const dagView: DagView = this.dagViewMap.get(tabId);
        if (!dagView) {
            return;
        }

        dagView.updateDatasetProgress(stats, nodeId);
    }

    /**
     * DagViewManager.Instance.resetActiveDagTab
     */
    public resetActiveDagTab(): void {
        this.activeDagTab = null;
        this.activeDag = null;
        this.activeDagView = null;
        DagCategoryBar.Instance.updateCategories(this.activeDagTab);
        this._updateDagView();
    }


    public selectNodes(tabId: string, nodeIds?: DagNodeId[]): JQuery {
        let $node: JQuery;
        if (!nodeIds) {
            const $dfArea = this._getAreaByTab(tabId);
            $node = $dfArea.find(".operator");
            DagView.selectNode($node);
            const $comments = $dfArea.find(".comment");
            DagView.selectNode($comments);
            $node = $node.add($comments);
        } else {
            nodeIds.forEach((nodeId) => {
                $node = this.getNode(nodeId, tabId);
                DagView.selectNode($node);
            });
            return $node || $();
        }
        return $node;
    }

    public render($dfArea?: JQuery, graph?: DagGraph) {
        if (!this._setup) {
            return;
        }
        // set activedag here
        $dfArea = $dfArea || this._getActiveArea();
        if ($dfArea.closest("#dagView").length && $dfArea.hasClass("rendered")) {
            return;
        }
        graph = graph || this.activeDag;
        const tabId = graph.getTabId();
        let containerSelector;
        if ($dfArea.closest("#dagView").length) {
            containerSelector = "#dagView";
        } else {
            containerSelector = this.containerSelector;
        }
        const newDagView = new DagView($dfArea, graph, containerSelector);
        this.dagViewMap.set(graph.getTabId(), newDagView);

        if (this.activeDag && tabId === this.activeDag.getTabId()) {
            // when rerendering graph, need to reset activeDag to new graph
            if (this.activeDagView) {
                this.activeDagView.unfocus();
            }
            this.activeDag = graph;
            this.activeDagView = newDagView;
            this.activeDagTab = DagTabManager.Instance.getTabById(tabId) || dagTab;
            this.activeDagView.focus();
        }
        newDagView.render();
    }

    public getDagViewById(tabId: string): DagView {
        return this.dagViewMap.get(tabId);
    }

    public addInstructionNode(): void {
        this.activeDagView.addInstructionNode();
    }

    public removeInstructionNode(nodeInfoToReplace?: {}): void {
        this.activeDagView.removeInstructionNode(nodeInfoToReplace);
    }


    /**
     * DagViewManager.Instance.newNode
     * @param dagId
     * @param nodeInfo
     */
    public newNode(nodeInfo: DagNodeInfo): DagNode {
        return this.activeDagView.newNode(nodeInfo);
    }


    /**
     * DagViewManager.Instance.newComment
     */
    public newComment(
        commentInfo: CommentInfo,
        isFocus?: boolean,
        tabId?: string
    ): XDPromise<void> {
        let dagView = this.activeDagView;
        if (tabId) {
            dagView = this.dagViewMap.get(tabId);
        }
        return dagView.newComment(commentInfo, isFocus);
    }

    /**
     * DagViewManager.Instance.addBackNodes
     * @param nodeIds
     * @param tabId
     * @param sliceInfo?
     * used for undoing/redoing operations
     */
    public addBackNodes(
        nodeIds: DagNodeId[],
        tabId: string,
        spliceInfo?,
        identifiers?
    ): XDPromise<void> {
        if (!this.dagViewMap.get(tabId)) {
            return PromiseHelper.reject("Module not found");
        }
        return this.dagViewMap.get(tabId).addBackNodes(nodeIds, spliceInfo, identifiers);
    }

    /**
     * DagViewManager.Instance.run
     * // run the entire dag,
     * // if no nodeIds passed in then it will execute all the nodes
     */
    public run(nodeIds?: DagNodeId[], optimized?: boolean, generateOptimizedDataflow?: boolean, noAutoPreview?: boolean, rerun?: boolean): XDPromise<void> {
        if (this.activeDagView == null) {
            return PromiseHelper.reject();
        }
        return this.activeDagView.run(nodeIds, optimized, generateOptimizedDataflow, noAutoPreview, rerun);
    }

    /**
     * DagViewManager.Instance.runWithHead
     * @param nodeId
     */
    public runWithHead(nodeId: string): XDPromise<void> {
        if (this.activeDag == null) {
            return PromiseHelper.reject();
        }
        const nodeIds: string[] = this.activeDag.getConnectedNodesFromHead(nodeId);
        return this.run(nodeIds);
    }

    /**
     * DagViewManager.Instance.highlightGraph
     * @param headNodeId
     */
    public highlightGraph(headNodeId: string | null): void {
        if (this.activeDagView == null) {
            return;
        }
        const $dfArea = DagViewManager.Instance.getActiveArea();
        $dfArea.find(".graphHighLightSelection").remove();
        if (headNodeId == null) {
            return;
        }
        const nodeIds: string[] = this.activeDag.getConnectedNodesFromHead(headNodeId);
        nodeIds.forEach((nodeId) => {
            const $node = this.activeDagView.getNodeElById(nodeId);
            DagView.addSelection($node, "graphHighLightSelection");
        });
    }

    /**
     * DagViewManager.Instance.generateOptimizedDataflow
     * @param nodeIds
     */
    public generateOptimizedDataflow(nodeIds?: DagNodeId[]): XDPromise<void> {
        if (this.activeDagView == null) {
            return PromiseHelper.reject();
        }
        return this.activeDagView.run(nodeIds, true, true);
    }


    public lockConfigNode(nodeId: DagNodeId, tabId?: string): string {
        if (!tabId) {
            tabId = this.activeDagTab.getId();
        }
        if (this.dagViewMap.has(tabId)) {
            return this.dagViewMap.get(tabId).lockConfigNode(nodeId);
        }
    }

    /**
     * DagViewManager.Instance.unlockConfigNode
     * @param nodeId
     */
    public unlockConfigNode(nodeId: DagNodeId, tabId: string): void {
        if (this.dagViewMap.has(tabId)) {
            this.dagViewMap.get(tabId).unlockConfigNode(nodeId);
        }
    }

     /**
     * DagViewManager.Instance.isNodeLocked
     * @param nodeId
     * @param tabId
     */
    public isNodeLocked(nodeId: DagNodeId, tabId?: string): boolean {
        tabId = tabId || this.activeDagTab.getId();
        if (this.dagViewMap.has(tabId)) {
            return this.dagViewMap.get(tabId).isNodeLocked(nodeId);
        }
        return false;
    }

    /**
     * DagViewManager.Instance.isNodeLocked
     * @param nodeId
     * @param tabId
     */
    public isNodeConfigLocked(nodeId: DagNodeId, tabId?: string): boolean {
        tabId = tabId || this.activeDagTab.getId();
        if (this.dagViewMap.has(tabId)) {
            return this.dagViewMap.get(tabId).isNodeConfigLocked(nodeId);
        }
        return false;
    }


    public deselectNodes(): void {
        if (this.activeDagView) {
            this.activeDagView.deselectNodes();
        }
    }


    /**
     * DagViewManager.Instance.removeNode
     * @param nodeId
     *  removes node from DagGraph, remove $element, connection lines, update
     * connector classes
     */
    public removeNodes(nodeIds: DagNodeId[], tabId: string): XDPromise<void> {
        return this.dagViewMap.get(tabId).removeNodes(nodeIds);
    }

    /**
     * DagViewManager.Instance.moveNodes
     * @param dagId
     * @param nodeInfos
     * @param graphDimensions
     */
    public moveNodes(
        tabId: string,
        nodeInfos: NodeMoveInfo[],
        graphDimensions?: Coordinate
    ): XDPromise<void> {
        if (!this.dagViewMap.has(tabId)) {
            return PromiseHelper.reject();
        }
        return this.dagViewMap.get(tabId).moveNodes(nodeInfos, graphDimensions);
    }


    /**
     * DagViewManager.Instance.copyNodes
     * @param nodeIds
     */
    public copyNodes(nodeIds: DagNodeId[]): string {
        if (!nodeIds.length) {
            return "";
        }
        return this.activeDagView.copyNodes(nodeIds);
    }

     /**
     * DagViewManager.Instance.cutNodes
     * @param nodeIds
     */
    public cutNodes(nodeIds: DagNodeId[]): string {
        return this.activeDagView.cutNodes(nodeIds);
    }

    public triggerCopy(): void {
        this._isCopying = true;
        document.execCommand("copy");
        this._isCopying = false;
    }

    public triggerCut(): void {
        this._isCopying = true;
        document.execCommand("cut");
        this._isCopying = false;
        DagNodeMenu.close();
    }

    public paste(content: string): any[] {
        if (!this.activeDagView) {
            return;
        }
        if (this.isDisableActions(true)) {
            return;
        }
        DagNodeMenu.close();
        return this.activeDagView.validateAndPaste(content);
    }

    /**
     * @deprecated
     * @param nodeIds
     */
    public hasOptimizedNode(nodeIds?: DagNodeId[]): boolean {
        return this.activeDagView.hasOptimizedNode(nodeIds);
    }

    public hasOptimizableNode(nodeIds?: DagNodeId[]): boolean {
        return this.activeDagView.hasOptimzableNode(nodeIds);
    }

    /**
     * DagViewManager.Instance.disconnect
     * @param parentNodeId
     * @param childNodeId
     * removes connection from DagGraph, connection line, updates connector classes
     */
    public disconnectNodes(
        parentNodeId: DagNodeId,
        childNodeId: DagNodeId,
        connectorIndex: number,
        tabId: string
    ): XDPromise<void> {
        return this.dagViewMap.get(tabId).disconnectNodes(parentNodeId, childNodeId, connectorIndex);
    }


    /**
     * DagViewManager.Instance.connectNodes
     * @param parentNodeId
     * @param childNodeId
     * @param connectorIndex
     * @param tabId
     * @param isReconnect
     * connects 2 nodes and draws line
     */
    public connectNodes(
        parentNodeId: DagNodeId,
        childNodeId: DagNodeId,
        connectorIndex: number,
        tabId: string,
        isReconnect?: boolean,
        spliceIn?: boolean,
        identifiers?: Map<number, string>,
        setNodeConfig?: {sourceColumn: string, destColumn: string, columnType: ColumnType, cast: boolean}[]
    ): XDPromise<void> {
        if (!this.dagViewMap.has(tabId)) {
            return PromiseHelper.reject();
        }
        return this.dagViewMap.get(tabId).connectNodes(parentNodeId, childNodeId, connectorIndex, isReconnect, spliceIn, identifiers, setNodeConfig);
    }


    /**
     * DagViewManager.Instance.autoAlign
     * @param tabId
     */
    public autoAlign(tabId: string): void {
        this.dagViewMap.get(tabId).autoAlign();
    }

    /**
     * DagViewManager.Instance.autoAddNode
     * @param newType
     * @param subType
     * @param parentNodeId
     * @param input
     * @param x
     * @param y
     * @param options
     */
    public async autoAddNode(
        newType: DagNodeType,
        subType?: DagNodeSubType,
        parentNodeId?: DagNodeId,
        input?: object,
        options: {
            nodeTitle?: string,
            configured?: boolean,
            forceAdd?: boolean,
            autoConnect?: boolean,
            x?: number,
            y?: number,
            byPassAlert?: boolean
        } = {}
    ): Promise<DagNode | null> {
        const dagTab = this.activeDagTab;
        if (dagTab == null) {
            return null;
        }
        try {
            if (dagTab instanceof DagTabExecuteOnly) {
                await dagTab.viewOnlyAlert(options.byPassAlert);
            } else if (dagTab instanceof DagTabUser && !dagTab.isEditable()) {
                await DagTabUser.viewOnlyAlert(dagTab);
            }
            return this.activeDagView.autoAddNode(newType, subType, parentNodeId, input, options);
        } catch (e) {
            console.error(e);
            return null;
        }
    }

    public getAllNodes(includeComments?: boolean): JQuery {
        return this.activeDagView.getAllNodes(includeComments);
    }

    public getSelectedNodes(
        includeSelecting?: boolean,
        includeComments?: boolean
    ): JQuery {
        return this.activeDagView.getSelectedNodes(includeSelecting, includeComments);
    }

    public getSelectedNodeIds(
        includeSelecting?: boolean,
        includeComments?: boolean
    ): DagNodeId[] {
        return this.activeDagView.getSelectedNodeIds(includeSelecting, includeComments);
    }


    public viewOptimizedDataflow(dagNode: DagNode, tabId: string): XDPromise<void> {
        return this.dagViewMap.get(tabId).viewOptimizedDataflow(dagNode);
    }

    public reset(nodeIds?: DagNodeId[], bypassResetAlert?: boolean, tableMsg?: boolean): XDPromise<void> {
        return this.activeDagView.reset(nodeIds, bypassResetAlert, tableMsg);
    }

    public deleteParentTablesFromNode(dagNodeId: DagNodeId): XDPromise<void> {
        if (!this.activeDagView) {
            return PromiseHelper.reject();
        }

        const deferred: XDDeferred<void> = PromiseHelper.deferred();
        Alert.show({
            title: DagTStr.DeleteTable,
            msg: DagTStr.DeleteParentTablesMsg,
            onConfirm: () => {
                resolve();
            },
            onCancel: () => {
                deferred.reject();
            }
        });

        // recusrively reset upfront graph
        let resolve = async () => {
            try {
                const startNode = this.activeDagTab.getGraph().getNode(dagNodeId);
                await this._recursiveDeleteParentNodes(this.activeDagTab.getId(), startNode);
                deferred.resolve();
            } catch (e) {
                console.error(e);
                Alert.error(IMDTStr.DeactivateTableFail, e.message);
            }
        };
        return deferred.promise();
    }

    private async _recursiveDeleteParentNodes(
        startTabId: string,
        startNode: DagNode
    ): Promise<void> {
        const stack: [string, DagNode][] = [[startTabId, startNode]];
        const visited = {}; // visited[tabId][nodeId] = true

        while (stack.length > 0) {
            const [tabId, node] = stack.pop();
            const nodeId: string = node.getId();
            if (visited[tabId] && visited[tabId][nodeId]) {
                // already visited, prevenet cyclic case
                continue;
            }
            visited[tabId] = visited[tabId] || {};
            visited[tabId][node.getId()] = true;

            const nodesToRest: DagNodeId[] = [];
            const cb = (currentNode: DagNode) => {
                if (currentNode.hasResult()) {
                    if (DagTblManager.Instance.isPinned(currentNode.getTable())) {
                        return true;
                    }
                    nodesToRest.push(currentNode.getId());
                }
            };
            const funcInNodes = DagGraph.getFuncInNodesFromDestNodes([node], false, cb);
            for (let funcInNode of funcInNodes) {
                if (!funcInNode.hasAcceessToLinkedGraph()) {
                    const tabToOpen = DagList.Instance.getDagTabById(funcInNode.getLinkedTabId());
                    if (tabToOpen != null) {
                        await DagTabManager.Instance.loadTab(tabToOpen, false, false);
                    }
                }
                const res = funcInNode.getLinkedNodeAndGraph();
                const linkedTabId: string = res.graph.getTabId();
                let funcOutNode: DagNodeDFOut = res.node;
                stack.push([linkedTabId, funcOutNode]);
            }

            // reset all tracked inNodes
            const currentTab = DagTabManager.Instance.getTabById(tabId);
            currentTab.resetNodes(nodesToRest);
        }
    }

    /**
     *
     * @param $node
     * @param text
     */
    public editDescription(
        nodeId: DagNodeId,
        text: string
    ): XDPromise<void> {
        return this.activeDagView.editDescription(nodeId, text);
    }

    /**
     * @param nodeId
     * @param tabId
     * @param text
     */
    public editNodeTitle(
        nodeId: DagNodeId,
        tabId: string,
        text: string
    ): XDPromise<void> {
        return this.dagViewMap.get(tabId).editNodeTitle(nodeId, text);
    }


    /**
     * DagViewManager.Instance.cancel
     * cancel entire run or execution
     */
    public cancel() {
        if (this.activeDagView != null) {
            this.activeDagView.cancel();
            DagGraphBar.Instance.setState(this.activeDagTab);
        }
    }

    public highlightLineage(
        nodeId: DagNodeId,
        childNodeId?: DagNodeId,
        type?: "add" | "rename" | "remove" | "hide" | "pull"
    ): void {
        this.activeDagView.highlightLineage(nodeId, childNodeId, type);
    }

    /**
     * Replace a group of nodes with a custom operator
     * @param nodeIds list of nodeIds need to be nested in the custom operator
     * @returns Promise with void
     * @description
     * 1. Create a custom operator with deep copies of the selected nodes
     * 2. Delete the selected nodes from current graph
     * 3. Add the custom operator to current graph
     * 4. Restore the connections
     * 5. Position the custom operator & update UI
     * 6. Persist the change to KVStore
     */
    public wrapCustomOperator(nodeIds: DagNodeId[]): XDPromise<void> {
        return this.activeDagView.wrapCustomOperator(nodeIds);
    }

    /**
     * Expand the Custom node into a sub graph in place for editing purpose
     * @param nodeId
     */
    public expandCustomNode(nodeId: DagNodeId): XDPromise<void> {
        return this.activeDagView.expandCustomNode(nodeId);
    }

    /**
     * Share a custom operator(node). Called by the node popup menu.
     * @param nodeId
     * @description
     * 1. Find the DagNode needs to be shared in the active DagGraph
     * 2. Make a deep copy of the node
     * 3. Call DagCategoryBar to add the copy to the category bar(and extra actions, such as persisting)
     * 4. Change the display name of the node
     * 5. Persist the tab to KVStore
     */
    public shareCustomOperator(nodeId: DagNodeId): XDPromise<void> {
        return this.activeDagView.shareCustomOperator(nodeId);
    }


    /**
     * Open a tab to show customOp's sub graph for editing
     * @param nodeId
     */
    public editCustomOperator(nodeId: DagNodeId): void {
        this.activeDagView.editCustomOperator(nodeId);
    }

    /**
     * DagViewManager.Instance.createSQLFunc
     * @param isFromSQLMode
     */
    public createSQLFunc(): void {
        let onSubmit = (name, numInput) => {
            DagView.newSQLFunc(name, numInput);
        };
        let onCancel: () => void = null;
        SQLFuncSettingModal.Instance.show(onSubmit, onCancel, null);
    }

    /**
     * Open a tab to show SQL sub graph for viewing purpose
     * @param nodeId
     */
    public inspectSQLNode(
        nodeId: DagNodeId,
        tabId: string
    ): XDPromise<string> {
        return DagView.inspectSQLNode(nodeId, tabId)
            .fail(function(err) {
                Alert.show({
                    title: "Inspect SQL Error",
                    msg: "Error details: " + xcHelper.parseError(err),
                    isAlert: true
                });
            });
    }

     /**
     * Expand the SQL node into a sub graph in place for editing purpose
     * @param nodeId
     */
    public expandSQLNode(nodeId: DagNodeId): XDPromise<void> {
        return this.activeDagView.expandSQLNode(nodeId)
            .fail(function(err) {
                Alert.show({
                    title: "Expand SQL Error",
                    msg: "Error details: " + xcHelper.parseError(err),
                    isAlert: true
                });
            });
    }

    /**
     * Change the zoom level (scale) of the active graph
     * @param isZoomIn
     * @description
     * 1. find the next zoom level
     * 2. store the change in scale
     * 3. set the scale in graph
     * 4. adjust dataflowAreaWrapper min-height and min-width
     * 5. adjust scrollbar
     */
    public zoom(isZoomIn: boolean, newScale?: number): void {
        if (this.activeDagView != null) {
            this.activeDagView.zoom(isZoomIn, newScale);
        }
    }

    /**
     * Check if modification to graph/nodes should be disabled, Ex. it's showing the subGraph of a customNode
     */
    public isDisableActions(alert?: boolean): boolean {
        return this.activeDagView == null || this.activeDagView.isDisableActions(alert);
    }

    public isViewOnly(): boolean {
        return this.activeDagView.isViewOnly();
    }

    public isLocked($dfArea): boolean {
        return $dfArea.hasClass("locked");
    }

    public toggleProgressTips(show?: boolean): void {
        if (show) {
            this.$dagView.addClass("showProgressTips");
        } else {
            this.$dagView.removeClass("showProgressTips");
        }
    }

    public toggleConfigInfo(show?: boolean): void {
        if (show) {
            this.$dagView.addClass("showConfigInfo");
        } else {
            this.$dagView.removeClass("showConfigInfo");
        }
    }

    public toggleTableName(show?: boolean): void {
        if (show) {
            this.$dagView.addClass("showTableName");
        } else {
            this.$dagView.removeClass("showTableName");
        }
    }

    public toggleLabels(show?: boolean): void {
        if (show) {
            this.$dagView.addClass("showLabels");
        } else {
            this.$dagView.removeClass("showLabels");
        }
    }

    public pinOperatorBar(show?: boolean): void {
        if (show) {
            this.$dagView.addClass("operatorBarPinned");
        } else {
            this.$dagView.removeClass("operatorBarPinned");
        }
    }



    /**
     * Cleanup job after a tab is closed
     * pass in either graph or graphId
     * @param graph
     * @description
     * #1 Remove all event handlers listening on the DagGraph associated with the closed tab
     * #2 ...
     */
    public cleanupClosedTab(graph?: DagGraph, graphId?: string) {
        if (!this._setup) {
            return;
        }
        let dagView: DagView;
        if (!graph) {
            dagView = this.dagViewMap.get(graphId);

            if (dagView) {
                graph = dagView.getGraph();
            }
        } else {
            dagView = this.dagViewMap.get(graph.getTabId());
        }
        if (!graph) {
            return;
        }
        if (dagView) {
            dagView.close();
        }
        DagView.cleanupClosedTab(graph);
        this.dagViewMap.delete(graph.getTabId());
    }

    public resetColumnDeltas(nodeId: DagNodeId): void {
        this.activeDagView.resetColumnDeltas(nodeId);
    }

    public resetColumnOrdering(nodeId: DagNodeId): void {
        this.activeDagView.resetColumnOrdering(nodeId);
    }

    /**
     * DagViewManager.Instance.getDisjointGraphs
     * @param appId
     * doesn't actually returns graphs, turns a set of module nodes that belong to graphs
     */
    public getDisjointGraphs(): {
        graph: DagGraph,
        disjointGraphs: Set<Set<DagNodeModule>>
    } {
        let map = this._getModules();
        let graph: DagGraph = this.buildModuleGraph(map);
        const disjointGraphs = <Set<Set<DagNodeModule>>>graph.getDisjointGraphs();

        return {
            graph: graph,
            disjointGraphs: disjointGraphs
        };
    }

    // return a map of tabId and the node
    private _getModules(): Map<string, DagNodeModule[]> {
        const map: Map<string, DagNodeModule[]> = new Map();
        const tabs = DagTabManager.Instance.getTabs().concat(DagTabManager.Instance.getCachedTabs());
        tabs.forEach((tab) => {
            if (tab.getApp() == null &&
                tab.getType() === DagTabType.User
            ) {
                const modules = (<DagTabUser>tab).getAppModules();
                map.set(tab.getId(), modules);
            }
        });
        return map;
    }

    public buildModuleGraph(map: Map<string, DagNodeModule[]>): DagGraph {
        const graph = new DagGraph();
        const moduleNodes: DagNodeModule[] = [];
        map.forEach((modules: DagNodeModule[]) => {
            modules.forEach((moduleNode) => {
                graph.addNode(moduleNode);
                moduleNodes.push(moduleNode);
            });
        });

        moduleNodes.forEach((childeNode) => {
            let index = 0;
            childeNode.linkIns.forEach((linkInNode) => {
                let res;
                try {
                    res = linkInNode.getLinkedNodeAndGraph();
                } catch (e) {
                    console.error(e);
                    return;
                }
                const linkedGraph = res.graph;
                const linkOutNode = res.node;
                const modules = map.get(linkedGraph.getTabId());
                const linkOutNodeId: DagNodeId = linkOutNode.getId();
                for (let moduleNode of modules) {
                    if (moduleNode.linkOuts.has(linkOutNodeId)) {
                        graph.connect(moduleNode.getId(), childeNode.getId(), index++);
                        break;
                    }
                }
            });
        });


        const positionInfo = DagView.getAutoAlignPositions(graph);
        positionInfo.nodeInfos.forEach((nodeInfo) => {
            graph.moveNode(nodeInfo.id, {
                x: nodeInfo.position.x + DagView.gridSpacing,
                y: nodeInfo.position.y + DagView.gridSpacing,
            });
        });
        graph.setDimensions(positionInfo.maxX + DagView.horzPadding + 100,
                            positionInfo.maxY + DagView.vertPadding + 100);

        return graph;
    }

    private _addEventListeners(): void {
        this.$dagView.find(".dataflowWrapBackground").on("click", ".newTab", () => {
            DagTabManager.Instance.newTab(true);
        });
    }

    private _getDagViewEl(): JQuery {
        return $("#dagView");
    }

    private _addDagViewListeners(): void {
        const self = this;

        // moving node in dataflow area to another position
        let operatorSelector = ".operator .main, .operator .iconArea, .comment, .operator .table, .operator .tblIcon";


        // connecting 2 nodes dragging the parent's connector
        this.$dfWrap.on("mousedown", ".operator .connector.out", function (event) {
            self.activeDagView.connectorOutMousedown(event, $(this));
        });

            // connecting 2 nodes dragging the child's connector
        this.$dfWrap.on("mousedown", ".operator .connector.in", function (event) {
            self.activeDagView.connectorInMousedown(event, $(this));
        });

        this.$dfWrap.on("click", ".graphHead", function () {
            self.activeDagView.graphHeadEditMode($(this));
        });

        this.$dfWrap.on("dblclick", ".nodeTitle", function () {
            self.activeDagView.nodeTitleEditMode($(this));
        });

        this.$dfWrap.on("click", ".paramTitle", function () {
            if (self.activeDagTab == null || self.activeDag == null) {
                return; // error case
            }
            if (self.isDisableActions(true)) {
                return; // invalid case
            }
            const $node: JQuery = $(this).closest(".operator");
            const node: DagNode = self.activeDag.getNode($node.data("nodeid"));
            if (node != null) {
                DagNodeMenu.execute("configureNode", {
                    node: node
                });
            }
        });

        let $dfWraps = this.$dfWrap;

         // drag select multiple nodes
        let $dfArea;
        let $els;
        $dfWraps.on("mousedown", function (event) {
            if (event.which !== 1 || self.activeDagTab == null ||
                (isSystemMac && event.ctrlKey)) {
                return;
            }
            let $target = $(event.target);
            $dfArea = self._getActiveArea();
            if ($target.closest(".dataflowAreaWrapper").length &&
                !$target.closest(".operator").length &&
                !$target.closest(".selection").length &&
                !$target.closest(".comment").length &&
                !$target.closest(".edge").length &&
                !$target.closest(".editableNodeTitle").length &&
                !$target.closest(".ui-resizable-handle").length) {
                new RectSelection(event.pageX, event.pageY, {
                    "id": "dataflow-rectSelection",
                    "$container": $dfArea.find(".dataflowAreaWrapper"),
                    "$scrollContainer": $dfArea,
                    "onStart": () => {
                        $dfArea.addClass("drawing");
                        $els = $dfArea.find(".operator");
                        $els = $els.add($dfArea.find(".comment"));
                        DagView.deselectNode($els);
                    },
                    "onDraw": _drawRect,
                    "onEnd": _endDrawRect
                });
            }
        });


        $dfWraps.on("mousedown", operatorSelector, function (event) {
            self.activeDagView.operatorMousedown(event, $(this), false);
        });

        $dfWraps.on("click", ".descriptionIcon", function () {
            const nodeId: DagNodeId = $(this).closest(".operator")
                .data("nodeid");
            DagDescriptionModal.Instance.show(nodeId, false);
        });

        $dfWraps.on("click", ".udfErrorIcon", function () {
            const nodeId: DagNodeId = $(this).closest(".operator")
                .data("nodeid");
            DagUDFErrorModal.Instance.show(nodeId);
        });

        // add classes to skewTh and skewTd because we can't use
        // css to control their hover states together
        $dfWraps.on("mouseenter", ".skewTh, .skewTd", function() {
            $(this).closest(".runStats").addClass("hoveringSkew");
        });

        $dfWraps.on("mouseleave", ".skewTh", function() {
            $(this).closest(".runStats").removeClass("hoveringSkew");
        });

        $dfWraps.on("mouseleave", ".skewTd", function() {
            $(this).closest(".runStats").removeClass("hoveringSkew");
        });

        $dfWraps.on("mouseup", ".skewTh, .skewTd", function() {
            let $runStats = $(this).closest(".runStats");
            let skewInfo = $runStats.data("skewinfo");
            SkewInfoModal.Instance.show(null, {tableInfo: skewInfo});
        });

        $dfWraps.on("mousedown", ".runStats", function() {
            const $tip = $(this);
            $tip.parent().append($tip);
        });

        function _drawRect(
            bound: ClientRect,
            selectTop: number,
            selectRight: number,
            selectBottom: number,
            selectLeft: number
        ): void {
            $els.each(function () {
                const $el = $(this);
                let opRect: ClientRect;
                if ($el.is(".operator")) {
                    opRect = $(this).find(".main")[0].getBoundingClientRect();
                } else {
                    opRect = this.getBoundingClientRect();
                }
                const opTop = opRect.top - bound.top;
                const opLeft = opRect.left - bound.left;
                const opRight = opRect.right - bound.left;
                const opBottom = opRect.bottom - bound.top;
                if (opTop > selectBottom || opLeft > selectRight ||
                    opRight < selectLeft || opBottom < selectTop) {
                    $el.removeClass("selecting");
                } else {
                    $el.addClass("selecting");
                }
            });
        }
        function _endDrawRect(_event: JQueryEventObject): void {
            $dfArea.removeClass("drawing");
            const $selectedEls = $dfArea.find(".selecting");
            if ($selectedEls.length === 0) {
                self.deselectNodes();
                DagNodeInfoPanel.Instance.hide();
            } else {
                $selectedEls.each(function () {
                    const $node = $(this);
                    $node.removeClass("selecting");
                    DagView.selectNode($node);
                });
            }
            $els = null;
        }
    }

    private _deselectAllNodes(): void {
        const $selected = this.$dfWrap.find(".selected");
        $selected.removeClass("selected");
        $selected.find(".selection").remove();
    }

    private _updateDagView(): void {
        const $dfWrapBg: JQuery = this.$dagView.find(".dataflowWrapBackground");
        DagNodeInfoPanel.Instance.hide();
        if (this.activeDagTab == null) {
            this.$dfWrap.addClass("xc-hidden");
            $dfWrapBg.removeClass("xc-hidden");
            this.$dagView.find(".searchArea, .categoryWrap, .operatorWrap").addClass("xc-disabled");
        } else {
            this.$dfWrap.removeClass("xc-hidden");
            $dfWrapBg.addClass("xc-hidden");
            this.$dagView.find(".searchArea, .categoryWrap, .operatorWrap").removeClass("xc-disabled");
            this._deselectAllNodes();
        }
        DagGraphBar.Instance.setState(this.activeDagTab);
        this._checkNodeValidation();
    }

    private _checkNodeValidation(): void {
        if (!this.activeDagTab) {
            return;
        }
        this.activeDagView.checkLinkInNodeValidation();
    }


    private async _viewAgg(dagNode: DagNodeAggregate): void {
        try {
            const evalStr: string = dagNode.getParam().evalString;
            const op: string = evalStr.substring(0, evalStr.indexOf("("));
            const title: string = xcStringHelper.replaceMsg(AggTStr.AggTitle, {
                op: op
            });
            let alertId: string = null;
            if (dagNode.getAggVal() == null) {
                // if aggVal is not ready yet, wait for it
                alertId = Alert.show({
                    title: title,
                    msg: "Fetching aggregate value, please wait...",
                    isAlert: true,
                    isInfo: true
                });
                await dagNode.waitForFetchingAggVal();
            }

            const aggVal = this._getAggValueFromNode(dagNode);
            const msg: string = xcStringHelper.replaceMsg(AggTStr.AggMsg, {
                val: aggVal
            });
            if (aggVal == null) {
                // error case
                Alert.error(AlertTStr.Error, "Aggregate value is empty, please reset and try agin");
            } else if (alertId != null) {
                // when the value is fetched first
                Alert.updateMsg(alertId, msg);
            } else {
                Alert.show({
                    title: title,
                    msg: msg,
                    isAlert: true,
                    isInfo: true
                });
            }
        } catch (e) {
            console.error(e);
            Alert.error(AlertTStr.Error, ErrTStr.Unknown);
        }
    }

    private _getAggValueFromNode(dagNode: DagNodeAggregate): string {
        let aggVal: string | number = dagNode.getAggVal();
        if (typeof aggVal === "string") {
            aggVal = `"${aggVal}"`;
        } else {
            aggVal = xcStringHelper.numToStr(<number>aggVal);
        }
        return aggVal;
    }

    private _getAreaByTab(tabId: string): JQuery {
        const index: number = DagTabManager.Instance.getTabIndex(tabId);
        if (index < 0) {
            return $();
        }
        return this.$dfWrap.find(".dataflowArea").eq(index);
    }


    private _getActiveArea(): JQuery {
        return this.$dfWrap.find(".dataflowArea.active");
    }
}
