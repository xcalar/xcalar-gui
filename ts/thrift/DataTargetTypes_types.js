//
// Autogenerated by Thrift Compiler (0.10.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


ExAddTargetSFInputT = function(args) {
  this.url = null;
  if (args) {
    if (args.url !== undefined && args.url !== null) {
      this.url = args.url;
    }
  }
};
ExAddTargetSFInputT.prototype = {};
ExAddTargetSFInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.url = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExAddTargetSFInputT.prototype.write = function(output) {
  output.writeStructBegin('ExAddTargetSFInputT');
  if (this.url !== null && this.url !== undefined) {
    output.writeFieldBegin('url', Thrift.Type.STRING, 1);
    output.writeString(this.url);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExAddTargetUDFInputT = function(args) {
  this.url = null;
  this.appName = null;
  if (args) {
    if (args.url !== undefined && args.url !== null) {
      this.url = args.url;
    }
    if (args.appName !== undefined && args.appName !== null) {
      this.appName = args.appName;
    }
  }
};
ExAddTargetUDFInputT.prototype = {};
ExAddTargetUDFInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.url = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.appName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExAddTargetUDFInputT.prototype.write = function(output) {
  output.writeStructBegin('ExAddTargetUDFInputT');
  if (this.url !== null && this.url !== undefined) {
    output.writeFieldBegin('url', Thrift.Type.STRING, 1);
    output.writeString(this.url);
    output.writeFieldEnd();
  }
  if (this.appName !== null && this.appName !== undefined) {
    output.writeFieldBegin('appName', Thrift.Type.STRING, 2);
    output.writeString(this.appName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExAddTargetSpecificInputT = function(args) {
  this.sfInput = null;
  this.udfInput = null;
  if (args) {
    if (args.sfInput !== undefined && args.sfInput !== null) {
      this.sfInput = new ExAddTargetSFInputT(args.sfInput);
    }
    if (args.udfInput !== undefined && args.udfInput !== null) {
      this.udfInput = new ExAddTargetUDFInputT(args.udfInput);
    }
  }
};
ExAddTargetSpecificInputT.prototype = {};
ExAddTargetSpecificInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sfInput = new ExAddTargetSFInputT();
        this.sfInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.udfInput = new ExAddTargetUDFInputT();
        this.udfInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExAddTargetSpecificInputT.prototype.write = function(output) {
  output.writeStructBegin('ExAddTargetSpecificInputT');
  if (this.sfInput !== null && this.sfInput !== undefined) {
    output.writeFieldBegin('sfInput', Thrift.Type.STRUCT, 2);
    this.sfInput.write(output);
    output.writeFieldEnd();
  }
  if (this.udfInput !== null && this.udfInput !== undefined) {
    output.writeFieldBegin('udfInput', Thrift.Type.STRUCT, 3);
    this.udfInput.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExExportTargetHdrT = function(args) {
  this.type = null;
  this.name = null;
  if (args) {
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    }
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
  }
};
ExExportTargetHdrT.prototype = {};
ExExportTargetHdrT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExExportTargetHdrT.prototype.write = function(output) {
  output.writeStructBegin('ExExportTargetHdrT');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 2);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExExportTargetT = function(args) {
  this.hdr = null;
  this.specificInput = null;
  if (args) {
    if (args.hdr !== undefined && args.hdr !== null) {
      this.hdr = new ExExportTargetHdrT(args.hdr);
    }
    if (args.specificInput !== undefined && args.specificInput !== null) {
      this.specificInput = new ExAddTargetSpecificInputT(args.specificInput);
    }
  }
};
ExExportTargetT.prototype = {};
ExExportTargetT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.hdr = new ExExportTargetHdrT();
        this.hdr.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.specificInput = new ExAddTargetSpecificInputT();
        this.specificInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExExportTargetT.prototype.write = function(output) {
  output.writeStructBegin('ExExportTargetT');
  if (this.hdr !== null && this.hdr !== undefined) {
    output.writeFieldBegin('hdr', Thrift.Type.STRUCT, 1);
    this.hdr.write(output);
    output.writeFieldEnd();
  }
  if (this.specificInput !== null && this.specificInput !== undefined) {
    output.writeFieldBegin('specificInput', Thrift.Type.STRUCT, 2);
    this.specificInput.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportCSVArgsT = function(args) {
  this.fieldDelim = null;
  this.recordDelim = null;
  this.quoteDelim = null;
  if (args) {
    if (args.fieldDelim !== undefined && args.fieldDelim !== null) {
      this.fieldDelim = args.fieldDelim;
    }
    if (args.recordDelim !== undefined && args.recordDelim !== null) {
      this.recordDelim = args.recordDelim;
    }
    if (args.quoteDelim !== undefined && args.quoteDelim !== null) {
      this.quoteDelim = args.quoteDelim;
    }
  }
};
ExInitExportCSVArgsT.prototype = {};
ExInitExportCSVArgsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.fieldDelim = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.recordDelim = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.quoteDelim = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportCSVArgsT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportCSVArgsT');
  if (this.fieldDelim !== null && this.fieldDelim !== undefined) {
    output.writeFieldBegin('fieldDelim', Thrift.Type.STRING, 1);
    output.writeString(this.fieldDelim);
    output.writeFieldEnd();
  }
  if (this.recordDelim !== null && this.recordDelim !== undefined) {
    output.writeFieldBegin('recordDelim', Thrift.Type.STRING, 2);
    output.writeString(this.recordDelim);
    output.writeFieldEnd();
  }
  if (this.quoteDelim !== null && this.quoteDelim !== undefined) {
    output.writeFieldBegin('quoteDelim', Thrift.Type.STRING, 3);
    output.writeString(this.quoteDelim);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportJSONArgsT = function(args) {
  this.array = null;
  if (args) {
    if (args.array !== undefined && args.array !== null) {
      this.array = args.array;
    }
  }
};
ExInitExportJSONArgsT.prototype = {};
ExInitExportJSONArgsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.array = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportJSONArgsT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportJSONArgsT');
  if (this.array !== null && this.array !== undefined) {
    output.writeFieldBegin('array', Thrift.Type.BOOL, 1);
    output.writeBool(this.array);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportSQLArgsT = function(args) {
  this.tableName = null;
  this.dropTable = null;
  this.createTable = null;
  if (args) {
    if (args.tableName !== undefined && args.tableName !== null) {
      this.tableName = args.tableName;
    }
    if (args.dropTable !== undefined && args.dropTable !== null) {
      this.dropTable = args.dropTable;
    }
    if (args.createTable !== undefined && args.createTable !== null) {
      this.createTable = args.createTable;
    }
  }
};
ExInitExportSQLArgsT.prototype = {};
ExInitExportSQLArgsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.tableName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.dropTable = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.createTable = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportSQLArgsT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportSQLArgsT');
  if (this.tableName !== null && this.tableName !== undefined) {
    output.writeFieldBegin('tableName', Thrift.Type.STRING, 1);
    output.writeString(this.tableName);
    output.writeFieldEnd();
  }
  if (this.dropTable !== null && this.dropTable !== undefined) {
    output.writeFieldBegin('dropTable', Thrift.Type.BOOL, 2);
    output.writeBool(this.dropTable);
    output.writeFieldEnd();
  }
  if (this.createTable !== null && this.createTable !== undefined) {
    output.writeFieldBegin('createTable', Thrift.Type.BOOL, 3);
    output.writeBool(this.createTable);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportFormatSpecificArgsT = function(args) {
  this.csv = null;
  this.json = null;
  this.sql = null;
  if (args) {
    if (args.csv !== undefined && args.csv !== null) {
      this.csv = new ExInitExportCSVArgsT(args.csv);
    }
    if (args.json !== undefined && args.json !== null) {
      this.json = new ExInitExportJSONArgsT(args.json);
    }
    if (args.sql !== undefined && args.sql !== null) {
      this.sql = new ExInitExportSQLArgsT(args.sql);
    }
  }
};
ExInitExportFormatSpecificArgsT.prototype = {};
ExInitExportFormatSpecificArgsT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.csv = new ExInitExportCSVArgsT();
        this.csv.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.json = new ExInitExportJSONArgsT();
        this.json.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.sql = new ExInitExportSQLArgsT();
        this.sql.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportFormatSpecificArgsT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportFormatSpecificArgsT');
  if (this.csv !== null && this.csv !== undefined) {
    output.writeFieldBegin('csv', Thrift.Type.STRUCT, 1);
    this.csv.write(output);
    output.writeFieldEnd();
  }
  if (this.json !== null && this.json !== undefined) {
    output.writeFieldBegin('json', Thrift.Type.STRUCT, 2);
    this.json.write(output);
    output.writeFieldEnd();
  }
  if (this.sql !== null && this.sql !== undefined) {
    output.writeFieldBegin('sql', Thrift.Type.STRUCT, 3);
    this.sql.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExSFFileSplitSpecificT = function(args) {
  this.numFiles = null;
  this.maxSize = null;
  if (args) {
    if (args.numFiles !== undefined && args.numFiles !== null) {
      this.numFiles = args.numFiles;
    }
    if (args.maxSize !== undefined && args.maxSize !== null) {
      this.maxSize = args.maxSize;
    }
  }
};
ExSFFileSplitSpecificT.prototype = {};
ExSFFileSplitSpecificT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.numFiles = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.maxSize = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExSFFileSplitSpecificT.prototype.write = function(output) {
  output.writeStructBegin('ExSFFileSplitSpecificT');
  if (this.numFiles !== null && this.numFiles !== undefined) {
    output.writeFieldBegin('numFiles', Thrift.Type.I64, 1);
    output.writeI64(this.numFiles);
    output.writeFieldEnd();
  }
  if (this.maxSize !== null && this.maxSize !== undefined) {
    output.writeFieldBegin('maxSize', Thrift.Type.I64, 2);
    output.writeI64(this.maxSize);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExSFFileSplitRuleT = function(args) {
  this.type = null;
  this.spec = null;
  if (args) {
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    }
    if (args.spec !== undefined && args.spec !== null) {
      this.spec = new ExSFFileSplitSpecificT(args.spec);
    }
  }
};
ExSFFileSplitRuleT.prototype = {};
ExSFFileSplitRuleT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.spec = new ExSFFileSplitSpecificT();
        this.spec.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExSFFileSplitRuleT.prototype.write = function(output) {
  output.writeStructBegin('ExSFFileSplitRuleT');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.spec !== null && this.spec !== undefined) {
    output.writeFieldBegin('spec', Thrift.Type.STRUCT, 2);
    this.spec.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportSFInputT = function(args) {
  this.fileName = null;
  this.format = null;
  this.splitRule = null;
  this.headerType = null;
  this.formatArgs = null;
  if (args) {
    if (args.fileName !== undefined && args.fileName !== null) {
      this.fileName = args.fileName;
    }
    if (args.format !== undefined && args.format !== null) {
      this.format = args.format;
    }
    if (args.splitRule !== undefined && args.splitRule !== null) {
      this.splitRule = new ExSFFileSplitRuleT(args.splitRule);
    }
    if (args.headerType !== undefined && args.headerType !== null) {
      this.headerType = args.headerType;
    }
    if (args.formatArgs !== undefined && args.formatArgs !== null) {
      this.formatArgs = new ExInitExportFormatSpecificArgsT(args.formatArgs);
    }
  }
};
ExInitExportSFInputT.prototype = {};
ExInitExportSFInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.fileName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.format = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.splitRule = new ExSFFileSplitRuleT();
        this.splitRule.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.headerType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.formatArgs = new ExInitExportFormatSpecificArgsT();
        this.formatArgs.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportSFInputT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportSFInputT');
  if (this.fileName !== null && this.fileName !== undefined) {
    output.writeFieldBegin('fileName', Thrift.Type.STRING, 1);
    output.writeString(this.fileName);
    output.writeFieldEnd();
  }
  if (this.format !== null && this.format !== undefined) {
    output.writeFieldBegin('format', Thrift.Type.I32, 2);
    output.writeI32(this.format);
    output.writeFieldEnd();
  }
  if (this.splitRule !== null && this.splitRule !== undefined) {
    output.writeFieldBegin('splitRule', Thrift.Type.STRUCT, 3);
    this.splitRule.write(output);
    output.writeFieldEnd();
  }
  if (this.headerType !== null && this.headerType !== undefined) {
    output.writeFieldBegin('headerType', Thrift.Type.I32, 4);
    output.writeI32(this.headerType);
    output.writeFieldEnd();
  }
  if (this.formatArgs !== null && this.formatArgs !== undefined) {
    output.writeFieldBegin('formatArgs', Thrift.Type.STRUCT, 5);
    this.formatArgs.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportUDFInputT = function(args) {
  this.fileName = null;
  this.format = null;
  this.headerType = null;
  this.formatArgs = null;
  if (args) {
    if (args.fileName !== undefined && args.fileName !== null) {
      this.fileName = args.fileName;
    }
    if (args.format !== undefined && args.format !== null) {
      this.format = args.format;
    }
    if (args.headerType !== undefined && args.headerType !== null) {
      this.headerType = args.headerType;
    }
    if (args.formatArgs !== undefined && args.formatArgs !== null) {
      this.formatArgs = new ExInitExportFormatSpecificArgsT(args.formatArgs);
    }
  }
};
ExInitExportUDFInputT.prototype = {};
ExInitExportUDFInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.fileName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.format = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.headerType = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.formatArgs = new ExInitExportFormatSpecificArgsT();
        this.formatArgs.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportUDFInputT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportUDFInputT');
  if (this.fileName !== null && this.fileName !== undefined) {
    output.writeFieldBegin('fileName', Thrift.Type.STRING, 1);
    output.writeString(this.fileName);
    output.writeFieldEnd();
  }
  if (this.format !== null && this.format !== undefined) {
    output.writeFieldBegin('format', Thrift.Type.I32, 2);
    output.writeI32(this.format);
    output.writeFieldEnd();
  }
  if (this.headerType !== null && this.headerType !== undefined) {
    output.writeFieldBegin('headerType', Thrift.Type.I32, 3);
    output.writeI32(this.headerType);
    output.writeFieldEnd();
  }
  if (this.formatArgs !== null && this.formatArgs !== undefined) {
    output.writeFieldBegin('formatArgs', Thrift.Type.STRUCT, 4);
    this.formatArgs.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExInitExportSpecificInputT = function(args) {
  this.sfInput = null;
  this.udfInput = null;
  if (args) {
    if (args.sfInput !== undefined && args.sfInput !== null) {
      this.sfInput = new ExInitExportSFInputT(args.sfInput);
    }
    if (args.udfInput !== undefined && args.udfInput !== null) {
      this.udfInput = new ExInitExportUDFInputT(args.udfInput);
    }
  }
};
ExInitExportSpecificInputT.prototype = {};
ExInitExportSpecificInputT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sfInput = new ExInitExportSFInputT();
        this.sfInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.udfInput = new ExInitExportUDFInputT();
        this.udfInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExInitExportSpecificInputT.prototype.write = function(output) {
  output.writeStructBegin('ExInitExportSpecificInputT');
  if (this.sfInput !== null && this.sfInput !== undefined) {
    output.writeFieldBegin('sfInput', Thrift.Type.STRUCT, 2);
    this.sfInput.write(output);
    output.writeFieldEnd();
  }
  if (this.udfInput !== null && this.udfInput !== undefined) {
    output.writeFieldBegin('udfInput', Thrift.Type.STRUCT, 3);
    this.udfInput.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExColumnNameT = function(args) {
  this.name = null;
  this.headerAlias = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
    if (args.headerAlias !== undefined && args.headerAlias !== null) {
      this.headerAlias = args.headerAlias;
    }
  }
};
ExColumnNameT.prototype = {};
ExColumnNameT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.headerAlias = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExColumnNameT.prototype.write = function(output) {
  output.writeStructBegin('ExColumnNameT');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.headerAlias !== null && this.headerAlias !== undefined) {
    output.writeFieldBegin('headerAlias', Thrift.Type.STRING, 2);
    output.writeString(this.headerAlias);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ExExportMetaT = function(args) {
  this.target = null;
  this.specificInput = null;
  this.createRule = null;
  this.sorted = null;
  this.numColumns = null;
  this.columns = null;
  if (args) {
    if (args.target !== undefined && args.target !== null) {
      this.target = new ExExportTargetHdrT(args.target);
    }
    if (args.specificInput !== undefined && args.specificInput !== null) {
      this.specificInput = new ExInitExportSpecificInputT(args.specificInput);
    }
    if (args.createRule !== undefined && args.createRule !== null) {
      this.createRule = args.createRule;
    }
    if (args.sorted !== undefined && args.sorted !== null) {
      this.sorted = args.sorted;
    }
    if (args.numColumns !== undefined && args.numColumns !== null) {
      this.numColumns = args.numColumns;
    }
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ExColumnNameT]);
    }
  }
};
ExExportMetaT.prototype = {};
ExExportMetaT.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.target = new ExExportTargetHdrT();
        this.target.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.specificInput = new ExInitExportSpecificInputT();
        this.specificInput.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.createRule = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.BOOL) {
        this.sorted = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.numColumns = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.columns = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = new ExColumnNameT();
          elem6.read(input);
          this.columns.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ExExportMetaT.prototype.write = function(output) {
  output.writeStructBegin('ExExportMetaT');
  if (this.target !== null && this.target !== undefined) {
    output.writeFieldBegin('target', Thrift.Type.STRUCT, 1);
    this.target.write(output);
    output.writeFieldEnd();
  }
  if (this.specificInput !== null && this.specificInput !== undefined) {
    output.writeFieldBegin('specificInput', Thrift.Type.STRUCT, 2);
    this.specificInput.write(output);
    output.writeFieldEnd();
  }
  if (this.createRule !== null && this.createRule !== undefined) {
    output.writeFieldBegin('createRule', Thrift.Type.I32, 3);
    output.writeI32(this.createRule);
    output.writeFieldEnd();
  }
  if (this.sorted !== null && this.sorted !== undefined) {
    output.writeFieldBegin('sorted', Thrift.Type.BOOL, 4);
    output.writeBool(this.sorted);
    output.writeFieldEnd();
  }
  if (this.numColumns !== null && this.numColumns !== undefined) {
    output.writeFieldBegin('numColumns', Thrift.Type.I32, 5);
    output.writeI32(this.numColumns);
    output.writeFieldEnd();
  }
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 6);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter7 in this.columns)
    {
      if (this.columns.hasOwnProperty(iter7))
      {
        iter7 = this.columns[iter7];
        iter7.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

